// This file is heavily based on (but not a direct copy of) the source code for .NET Core's libraries, by the .NET Foundation and Contributors.
// The original source code is available on GitHub at https://github.com/dotnet/corefx.
// The source code is licensed under the MIT license: https://github.com/dotnet/corefx/blob/master/LICENSE.TXT.
// This file was automatically generated by a T4 Text Template file (ValueTuple.tt).

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	// Helper
	void ForEachTuple(int count, Action<string, string[], string[], string[]> callback) {
		string[] genericNames = Enumerable.Range(1, count).Select(n => $"T{n}").ToArray();
		string[] itemNames = Enumerable.Range(1, count).Select(n => $"Item{n}").ToArray();
		string[] itemArgumentNames = Enumerable.Range(1, count).Select(n => $"item{n}").ToArray();

		for (int i = 1; i <= count; i++) {
			string[] curGenericNames = genericNames.Take(i).ToArray();
			string[] curItemNames = itemNames.Take(i).ToArray();
			string[] curItemArgumentNames = itemArgumentNames.Take(i).ToArray();
			string curGenericList = curGenericNames.Any() ? $"<{string.Join(", ", curGenericNames)}>" : string.Empty;
			string tupleName = $"ValueTuple{curGenericList}";
			callback(tupleName, curGenericNames, curItemNames, curItemArgumentNames);
		}
	}

	// Initialization
	const int maxTypes = 8;
	string[] nthStrings = { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eigth" };
#>
using System.Collections;
using System.Collections.Generic;

// ReSharper disable NonReadonlyMemberInGetHashCode
// ReSharper disable once CheckNamespace
namespace System {
	public partial struct ValueTuple {
<#
	ForEachTuple(maxTypes, (tupleName, curGenericNames, curItemNames, curItemArgumentNames) => {
		if (curGenericNames.Length < maxTypes) {
#>

		/// <summary>Creates a tuple with <#= curGenericNames.Length #> items.</summary>
<#
		for (int i = 0; i < curGenericNames.Length; i++) {
#>
		/// <typeparam name="<#= curGenericNames[i] #>">The type of the value tuple's <#= nthStrings[i] #> element.</typeparam>
		/// <param name="<#= curItemArgumentNames[i] #>">The value of the value tuple tuple's <#= nthStrings[i] #> element.</param>
<#
		}
#>
		/// <returns>A new <see cref="<#= tupleName.Replace("<", "{").Replace(">", "}") #>" />.</returns>
		public static <#= tupleName #> Create<#= (curGenericNames.Any() ? $"<{string.Join(", ", curGenericNames)}>" : string.Empty) #>(<#= string.Join(", ", curGenericNames.Select((genericName, i) => $"{genericName} {curItemArgumentNames[i]}")) #>) {
			return new <#= tupleName #>(<#= string.Join(", ", curItemArgumentNames) #>);
		}
<#
		}
	});
	
	{
		string[] curGenericNames = Enumerable.Range(1, maxTypes).Select(n => $"T{n}").ToArray();
		string[] curItemArgumentNames = Enumerable.Range(1, maxTypes).Select(n => $"item{n}").ToArray();
		string returnType = $"ValueTuple<{string.Join(", ", curGenericNames.Take(maxTypes - 1))}, ValueTuple<T{maxTypes}>>";
#>

		/// <summary>Creates a tuple with <#= curGenericNames.Length #> items.</summary>
<#
		for (int i = 0; i < curGenericNames.Length; i++) {
#>
		/// <typeparam name="<#= curGenericNames[i] #>">The type of the value tuple's <#= nthStrings[i] #> element.</typeparam>
		/// <param name="<#= curItemArgumentNames[i] #>">The value of the value tuple tuple's <#= nthStrings[i] #> element.</param>
<#
		}
#>
		/// <returns>A new <see cref="ValueTuple{<#= string.Join(", ", curGenericNames) #>}" /> where the last item is a <see cref="ValueTuple{T1}" /> containing the last item.</returns>
		public static <#= returnType #> Create<#= $"<{string.Join(", ", curGenericNames)}>" #>(<#= string.Join(", ", curGenericNames.Select((genericName, i) => $"{genericName} {curItemArgumentNames[i]}")) #>) {
			return new <#= returnType #>(<#= string.Join(", ", curItemArgumentNames.Take(maxTypes - 1)) #>, new ValueTuple<<#= curGenericNames.Last() #>>(<#= curItemArgumentNames.Last() #>));
		}
<#
	}
#>
	}
<#

	ForEachTuple(maxTypes, (tupleName, curGenericNames, curItemNames, curItemArgumentNames) => {
		int curTypes = curGenericNames.Length;
#>

	/// <summary>Represents a value tuple with <#= curTypes #> <#= (curTypes == 1 ? "component" : "components") #>.</summary>
<#
		for (int i = 0; i < curTypes; i++) {
#>
	/// <typeparam name="<#= curGenericNames[i] #>">The type of the value tuple's <#= nthStrings[i] #> element.</typeparam>
<#
		}
#>
	[Serializable]
	public struct <#= tupleName #> : IEquatable<<#= tupleName #>>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable<<#= tupleName #>>
	{
<#
		for (int curItem = 0; curItem < curTypes; curItem++) {
#>
		/// <summary>The <#= nthStrings[curItem] #> item in this <see cref="<#= tupleName.Replace("<", "{").Replace(">", "}") #>" />.</summary>
		public <#= curGenericNames[curItem] #> <#= curItemNames[curItem] #>;

<#
		}
#>
		/// <summary>Initializes a new value tuple.</summary>
<#
		for (int i = 0; i < curTypes; i++) {
#>
		/// <param name="<#= curItemArgumentNames[i] #>">The value of the <#= nthStrings[i] #> item.</param>
<#
		}
#>
		public ValueTuple(<#= string.Join(", ", Enumerable.Range(0, curTypes).Select(i => $"{curGenericNames[i]} {curItemArgumentNames[i]}")) #>) {
<#
			for (int i = 0; i < curTypes; i++) {
#>
			this.<#= curItemNames[i] #> = <#= curItemArgumentNames[i] #>;
<#
			}
#>
		}

		/// <inheritdoc />
        public override bool Equals(object obj) {
            return obj is <#= tupleName #> other && this.Equals(other);
        }

		/// <inheritdoc />
		public bool Equals(<#= tupleName #> other) {
            return <#= string.Join("\n                && ", Enumerable.Range(0, curTypes).Select(i => $"EqualityComparer<{curGenericNames[i]}>.Default.Equals(this.{curItemNames[i]}, other.{curItemNames[i]})")) #>;
        }

		/// <inheritdoc />
		public bool Equals(object other, IEqualityComparer comparer) {
            if (!(other is <#= tupleName #> otherTuple)) {
				return false;
			}

			return <#= string.Join("\n                && ", Enumerable.Range(0, curTypes).Select(i => $"comparer.Equals(this.{curItemNames[i]}, otherTuple.{curItemNames[i]})")) #>;
        }

		/// <inheritdoc />
        public int CompareTo(object obj) {
			return obj is <#= tupleName #> other ? this.CompareTo(other) : throw new ArgumentException();
		}

		/// <inheritdoc />
        public int CompareTo(<#= tupleName #> other) {
<#
			for (int i = 0; i < curTypes; i++) {
				string comparison = $"Comparer<{curGenericNames[i]}>.Default.Compare(this.{curItemNames[i]}, other.{curItemNames[i]})";
				if (i == curTypes - 1) {
#>
			return <#= comparison #>;		
<#
				} else if (i == 0) {
#>
			int result = <#= comparison #>;
			if (result != 0) {
				return result;
			}

<#
				} else {
#>
			result = <#= comparison #>;
			if (result != 0) {
				return result;
			}

<#
				}
			}
#>
        }

		/// <inheritdoc />
		public int CompareTo(object obj, IComparer comparer) {
			if (!(obj is <#= tupleName #> other)) {
				throw new ArgumentException();
			}
<#
			for (int i = 0; i < curTypes; i++) {
#>

<#
				string comparison = $"comparer.Compare(this.{curItemNames[i]}, other.{curItemNames[i]})";
				if (i == curTypes - 1) {
#>
			return <#= comparison #>;		
<#
				} else if (i == 0) {
#>
			int result = <#= comparison #>;
			if (result != 0) {
				return result;
			}
<#
				} else {
#>
			result = <#= comparison #>;
			if (result != 0) {
				return result;
			}
<#
				}
			}
#>
        }

		/// <inheritdoc />
		public override int GetHashCode() {
			return ValueTuple.CombineHashes(<#= string.Join(", ", curItemNames.Select(item => $"this.{item}?.GetHashCode() ?? 0")) #>);
		}

		/// <inheritdoc />
        public int GetHashCode(IEqualityComparer comparer) {
            return ValueTuple.CombineHashes(<#= string.Join(", ", curItemNames.Select(item => $"comparer.GetHashCode(this.{item})")) #>);
        }
	}
<#
	});
#>
}
